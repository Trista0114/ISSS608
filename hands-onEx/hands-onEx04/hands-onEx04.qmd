---
title: "Hands-on Exercise 04: Visualising Distribution"
author: "Chen.PengWei"
date-modified: "last-modified"
execute:
  echo: true
  eval: true
  warning: false
  freeze: true
---

# 1. Learning Outcome

------------------------------------------------------------------------

In this section, we will learn about two statistical graphic, namely **ridgeline plot** and **raincloud plot.**

::: callout-note
## Overview

**ridgeline plot** :we will know how to change the basic setting, color and adding stat meanings in the ridgeline plot

**raincloud plot:** we will know how to change the background setting and add the dot plots and box plots together with raincloud plot
:::

# 2. Getting started

::: panel-tabset
## Installing the packages

For the purpose of this exercise, the following R packages will be used, they are:

-   ggridges, a ggplot2 extension specially designed for plotting ridgeline plots

-   ggdist, a ggplot2 extension spacially desgin for visualising distribution and uncertainty

-   tidyverse, a family of R packages to meet the modern data science and visual communication needs

-   ggthemes, a ggplot extension that provides the user additional themes, scales, and geoms for the ggplots package

-   colorspace, an R package provides a broad toolbox for selecting individual colors or color palettes, manipulating these colors, and employing them in various kinds of visualisations.

```{r}
pacman::p_load(ggdist, ggridges, ggthemes,
               colorspace, tidyverse)
```

## Importing the data

In this exercise, we are still using the Exam_data.csv.

```{r}
exam <- read_csv("C:/Trista0114/ISSS608/hands-onEx/hands-onEx01/Exam_data.csv")
```

## Understanding the data

Year end examination grades of a cohort of primary 3 students from a local school. There are a total of seven attributes. Four of them are categorical data type and the other three are in continuous data type.

-   The categorical attributes are: ID, CLASS, GENDER and RACE.

-   The continuous attributes are: MATHS, ENGLISH and SCIENCE.

    ![](images/螢幕擷取畫面%202025-01-15%20135148.png)
:::

# 3. Visualising Distribution with Ridgeline Plot

------------------------------------------------------------------------

[*Ridgeline plot*](https://www.data-to-viz.com/graph/ridgeline.html) (sometimes called *Joyplot*) is a data visualisation technique for revealing the distribution of a numeric value for several groups. 

::: callout-note
## Timing of using Ridgeline plots

-   When there are a **large number of groups** that need to be presented, the Ridgeline Plot can effectively utilize space and avoid traditional distribution charts from taking up too much space due to excessive spacing. Its characteristic is that groups overlap each other, making it visually more compact. However, if there are fewer than 5 groups, other distribution plots may be a better choice.

-   Ridgeline plots are particularly useful for presenting data with **obvious patterns** , such as clear rankings between groups. However, if the data lacks obvious patterns, excessive overlap may clutter the chart and make it difficult to provide valuable insights.
:::

## 3.1 Plotting ridgeline graph: ggridges method

ggridges package provides two main geom to plot gridgeline plots, they are: [`geom_ridgeline()`](https://wilkelab.org/ggridges/reference/geom_ridgeline.html) and [`geom_density_ridges()`](https://wilkelab.org/ggridges/reference/geom_density_ridges.html). The former takes height values directly to draw the ridgelines, and the latter first estimates data densities and then draws those using ridgelines.

::: panel-tabset
## The plot

```{r}
#| echo: false
ggplot(exam, 
       aes(x = ENGLISH, 
           y = CLASS)) +
  geom_density_ridges(
    scale = 3,
    rel_min_height = 0.01,
    bandwidth = 3.4,
    fill = lighten("#7097BB", .3),
    color = "white"
  ) +
  scale_x_continuous(
    name = "English grades",
    expand = c(0, 0)
    ) +
  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +
  theme_ridges()
```

## The code

Adds extra space around the y-axis to prevent the ridges from being cut off at the top and bottom. The `add` argument adds specific padding values to the axis limits.

```{r,eval=FALSE}
ggplot(exam, 
       aes(x = ENGLISH, 
           y = CLASS)) +
  geom_density_ridges(
    scale = 3,# Adjusts the vertical scaling of the ridges to control overlap
    rel_min_height = 0.01,
    bandwidth = 3.4,#Controls the smoothness of the density curves. 
    fill = lighten("#7097BB", .3),
    color = "white"
  ) +
  scale_x_continuous(
    name = "English grades",
    expand = c(0, 0)
    ) +
  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) + #Customizes the y-axis 
  theme_ridges()
```
:::

## 3.2 Varying fill colors along the x axis

Sometimes we would like to have the area under a ridgeline not filled with a single solid color but rather with colors that vary in some form along the x axis. This effect can be achieved by using either [`geom_ridgeline_gradient()`](https://wilkelab.org/ggridges/reference/geom_ridgeline_gradient.html) or [`geom_density_ridges_gradient()`](https://wilkelab.org/ggridges/reference/geom_ridgeline_gradient.html).

Both geoms work just like `geom_ridgeline()` and `geom_density_ridges()`, except that they allow for varying fill colors. However, they do not allow for alpha transparency in the fill. For technical reasons, we can have **changing fill colors or transparency but not both.**

::: panel-tabset
## The plot

```{r}
#| echo: false
ggplot(exam, 
       aes(x = ENGLISH, 
           y = CLASS,
           fill = stat(x))) +
  geom_density_ridges_gradient(
    scale = 3,
    rel_min_height = 0.01) +
  scale_fill_viridis_c(name = "English grades",
                       option = "C") +
  scale_x_continuous(
    name = "English grades",
    expand = c(0, 0)
  ) +
  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +
  theme_ridges()
```

## The code

**`scale_fill_viridis_c()`** applies a **Viridis color scale** for **continuous** data (`_c` stands for "continuous"). Options inside the **`scale_fill_viridis_c()`** can be "A", "B", "C", "D", and "E", each with different color gradients.

```{r,eval=FALSE}
ggplot(exam, 
       aes(x = ENGLISH, 
           y = CLASS,
           fill = stat(x))) +
  geom_density_ridges_gradient(
    scale = 3,
    rel_min_height = 0.01) +
  scale_fill_viridis_c(name = "English grades",
                       option = "C") +
  scale_x_continuous(
    name = "English grades",
    expand = c(0, 0)
  ) +
  scale_y_discrete(name = NULL, expand = expansion(add = c(0.2, 2.6))) +
  theme_ridges()
```
:::

## 3.3 Mapping the probabilities

Beside providing additional geom objects to support the need to plot ridgeline plot, ggridges package also provides a stat function called [`stat_density_ridges()`](https://wilkelab.org/ggridges/reference/stat_density_ridges.html) that replaces [`stat_density()`](https://ggplot2.tidyverse.org/reference/geom_density.html) of ggplot2.

Figure below is plotted by mapping the probabilities calculated by using `stat(ecdf)` which represent the empirical cumulative density function for the distribution of English score.

::: callout-important
It is important include the argument `calc_ecdf = TRUE` in `stat_density_ridges()`.
:::

::: panel-tabset
## The plot

This design helps to highlight the main areas of concentration of grades.

```{r}
ggplot(exam,
       aes(x = ENGLISH, 
           y = CLASS, 
           fill = 0.5 - abs(0.5-stat(ecdf)))) +
  stat_density_ridges(geom = "density_ridges_gradient", 
                      calc_ecdf = TRUE) +
  scale_fill_viridis_c(name = "Tail probability",
                       direction = -1) +
  theme_ridges()

```

## The code

`fill = 0.5 - abs(0.5 - stat(ecdf))`:

-   `stat(ecdf)` computes the **empirical cumulative distribution function (ECDF)**, returning values between 0 and 1.
-   `abs(0.5 - stat(ecdf))` calculates the distance of each value from the **median (0.5)**.
-   `0.5 - abs(0.5 - stat(ecdf))` ensures that **the central part of the distribution is highlighted**, while the tails are less emphasized.
-   `direction = -1` reverses the color gradient, typically making lower values appear lighter and higher values darker (or vice versa).

```{r,eval=FALSE}
ggplot(exam,
       aes(x = ENGLISH, 
           y = CLASS, 
           fill = 0.5 - abs(0.5-stat(ecdf)))) +
  stat_density_ridges(geom = "density_ridges_gradient", 
                      calc_ecdf = TRUE) +
  scale_fill_viridis_c(name = "Tail probability",
                       direction = -1) + # reverses the color gradient
  theme_ridges()
```
:::

## 3.4 Ridgeline plots with quantile lines

y using [`geom_density_ridges_gradient()`](https://wilkelab.org/ggridges/reference/geom_ridgeline_gradient.html), we can colour the ridgeline plot by quantile, via the calculated `stat(quantile)` aesthetic as shown in the figure below.

::: panel-tabset
## The plot

```{r}
#| echo: false
ggplot(exam,
       aes(x = ENGLISH, 
           y = CLASS, 
           fill = factor(stat(quantile))
           )) +
  stat_density_ridges(
    geom = "density_ridges_gradient",
    calc_ecdf = TRUE, 
    quantiles = 4,
    quantile_lines = TRUE) +
  scale_fill_viridis_d(name = "Quartiles") +
  theme_ridges()
```

## The code

-   `quantiles = 4` divides the data into **four quartiles**.
-   `quantile_lines = TRUE` adds **vertical lines at each quartile boundary**, making it easier to see the quartile divisions.

```{r,eval=FALSE}
ggplot(exam,
       aes(x = ENGLISH, 
           y = CLASS, 
           fill = factor(stat(quantile))
           )) +
  stat_density_ridges(
    geom = "density_ridges_gradient",
    calc_ecdf = TRUE, 
    quantiles = 4,
    quantile_lines = TRUE) +
  scale_fill_viridis_d(name = "Quartiles") +
  theme_ridges()
```
:::

Instead of using number to define the quantiles, we can also specify quantiles by cut points such as 2.5% and 97.5% tails to colour the ridgeline plot as shown in the figure below.

::: panel-tabset
## The plot

```{r}
#| echo: false
ggplot(exam,
       aes(x = ENGLISH, 
           y = CLASS, 
           fill = factor(stat(quantile))
           )) +
  stat_density_ridges(
    geom = "density_ridges_gradient",
    calc_ecdf = TRUE, 
    quantiles = c(0.025, 0.975)
    ) +
  scale_fill_manual(
    name = "Probability",
    values = c("#FF0000A0", "#A0A0A0A0", "#0000FFA0"),
    labels = c("(0, 0.025]", "(0.025, 0.975]", "(0.975, 1]")
  ) +
  theme_ridges()
```

## The code

quantiles = c(0.025, 0.975)

```{r,eval=FALSE}
ggplot(exam,
       aes(x = ENGLISH, 
           y = CLASS, 
           fill = factor(stat(quantile))
           )) +
  stat_density_ridges(
    geom = "density_ridges_gradient",
    calc_ecdf = TRUE, 
    quantiles = c(0.025, 0.975)
    ) +
  scale_fill_manual(
    name = "Probability",
    values = c("#FF0000A0", "#A0A0A0A0", "#0000FFA0"),
    labels = c("(0, 0.025]", "(0.025, 0.975]", "(0.975, 1]")
  ) +
  theme_ridges()
```
:::

# 4. Visualising Distribution with Raincloud Plot

------------------------------------------------------------------------

Raincloud Plot is a data visualisation techniques that produces a half-density to a distribution plot. It gets the name because the density plot is in the shape of a “raincloud”. It shows the densities that the traditional box-plot does not.

In this section, you will learn how to create a raincloud plot to visualise the distribution of English score by race. It will be created by using functions provided by **ggdist** and ggplot2 packages.

## 4.1 Plotting a Half Eye graph

First, we will plot a Half-Eye graph by using [`stat_halfeye()`](https://mjskay.github.io/ggdist/reference/stat_halfeye.html) of **ggdist** package.

This produces a Half Eye visualization, which is contains a half-density and a slab-interval.

::: panel-tabset
## The plot

```{r}
#| echo: false
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.2,
               .width = 0,
               point_colour = NA)
```

## The code

We remove the slab interval by setting .width = 0 and point_colour = NA.

-   `adjust = 0.5` : Controls the **smoothing bandwidth** of the density estimate.
-   **`justification = -0.2 :`** Adjusts the alignment of the half-eye plot

```{r,eval=FALSE}
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.2,
               .width = 0,
               point_colour = NA )
```
:::

## 4.2 Adding the boxplot with `geom_boxplot()`

Next, we will add the second geometry layer using [`geom_boxplot()`](https://r4va.netlify.app/chap09) of ggplot2. This produces a narrow boxplot. We reduce the width and adjust the opacity.

::: panel-tabset
## The plot

```{r}
#| echo: false
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.2,
               .width = 0,
               point_colour = NA) +
  geom_boxplot(width = .20,
               outlier.shape = NA)
```

## The code

```{r,eval=FALSE}
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.2,
               .width = 0,
               point_colour = NA) +
  geom_boxplot(width = .20,
               outlier.shape = NA)
```
:::

## 4.3 Adding the Dot Plots with `stat_dots()`

Next, we will add the third geometry layer using [`stat_dots()`](https://mjskay.github.io/ggdist/reference/stat_dots.html) of ggdist package. This produces a half-dotplot, which is similar to a histogram that indicates the number of samples (number of dots) in each bin. We select side = “left” to indicate we want it on the left-hand side.

::: panel-tabset
## The plot

```{r}
#| echo: false
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.2,
               .width = 0,
               point_colour = NA) +
  geom_boxplot(width = .20,
               outlier.shape = NA) +
  stat_dots(side = "left", 
            justification = 1.2, 
            binwidth = .5,
            dotsize = 2)
```

## The code

```{r,eval=FALSE}
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.2,
               .width = 0,
               point_colour = NA) +
  geom_boxplot(width = .20,
               outlier.shape = NA) +
  stat_dots(side = "left", 
            justification = 1.2, 
            binwidth = .5,
            dotsize = 2)
```
:::

## 4.4 Finishing touch

Lastly, [`coord_flip()`](https://ggplot2.tidyverse.org/reference/coord_flip.html) of ggplot2 package will be used to flip the raincloud chart horizontally to give it the raincloud appearance. At the same time, `theme_economist()` of ggthemes package is used to give the raincloud chart a professional publishing standard look.

::: panel-tabset
## The plot

```{r}
#| echo: false
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.2,
               .width = 0,
               point_colour = NA) +
  geom_boxplot(width = .20,
               outlier.shape = NA) +
  stat_dots(side = "left", 
            justification = 1.2, 
            binwidth = .5,
            dotsize = 1.5) +
  coord_flip() +
  theme_economist()
```

## The code

```{r,eval=FALSE}
ggplot(exam, 
       aes(x = RACE, 
           y = ENGLISH)) +
  stat_halfeye(adjust = 0.5,
               justification = -0.2,
               .width = 0,
               point_colour = NA) +
  geom_boxplot(width = .20,
               outlier.shape = NA) +
  stat_dots(side = "left", 
            justification = 1.2, 
            binwidth = .5,
            dotsize = 1.5) +
  coord_flip() +
  theme_economist()
```
:::

# 5. Reference

-   [Introducing Ridgeline Plots (formerly Joyplots)](https://blog.revolutionanalytics.com/2017/07/joyplots.html)

-   Claus O. Wilke [Fundamentals of Data Visualization](https://clauswilke.com/dataviz/) especially Chapter [6](https://clauswilke.com/dataviz/visualizing-amounts.html), [7](https://clauswilke.com/dataviz/histograms-density-plots.html), [8](https://clauswilke.com/dataviz/ecdf-qq.html), [9](https://clauswilke.com/dataviz/boxplots-violins.html) and [10](https://clauswilke.com/dataviz/visualizing-proportions.html).

-   Allen M, Poggiali D, Whitaker K et al. [“Raincloud plots: a multi-platform tool for robust data. visualization”](https://wellcomeopenresearch.org/articles/4-63) \[version 2; peer review: 2 approved\]. Welcome Open Res 2021, pp. 4:63.

-   [Dots + interval stats and geoms](https://mjskay.github.io/ggdist/articles/dotsinterval.html)
